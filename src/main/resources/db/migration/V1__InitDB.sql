-- ===================== Таблица пользователей =================
-- Table: public.users
-- DROP TABLE public.users;

CREATE TABLE public.users
(
    "firstName" character varying(120) COLLATE pg_catalog."default",
    "lastName" character varying(120) COLLATE pg_catalog."default",
    login character varying(50) COLLATE pg_catalog."default" NOT NULL,
    "userId" integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    "userPassword" character varying(50) COLLATE pg_catalog."default",
    CONSTRAINT users_pk PRIMARY KEY ("userId"),
    CONSTRAINT login UNIQUE (login)
)

TABLESPACE pg_default;

ALTER TABLE public.users
    OWNER to postgres;

-- Index: login_Idx
-- DROP INDEX public."login_Idx";
CREATE INDEX "login_Idx"
    ON public.users USING btree
    (login COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;

-- Index: userId_Idx
-- DROP INDEX public."userId_Idx";
CREATE INDEX "userId_Idx"
    ON public.users USING btree
    ("userId" ASC NULLS LAST)
    TABLESPACE pg_default;

--================== Таблица вопросов ===================
-- Table: public.questions
-- DROP TABLE public.questions;

CREATE TABLE public.questions
(
    "questId" integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    "questText" character varying(255) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "questionId_PK" PRIMARY KEY ("questId")
)

TABLESPACE pg_default;

ALTER TABLE public.questions
    OWNER to postgres;

-- Index: questId_Idx
-- DROP INDEX public."questId_Idx";

CREATE INDEX "questId_Idx"
    ON public.questions USING btree
    ("questId" ASC NULLS LAST)
    TABLESPACE pg_default;

ALTER TABLE public.questions
    CLUSTER ON "questId_Idx";

--============= Таблица ответов ================
-- Table: public.answers
-- DROP TABLE public.answers;

CREATE TABLE public.answers
(
    "answerText" character varying(255) COLLATE pg_catalog."default",
    "answerId" integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    CONSTRAINT "answerId_PK" PRIMARY KEY ("answerId"),
    CONSTRAINT "answerId" UNIQUE ("answerId")
)

TABLESPACE pg_default;

ALTER TABLE public.answers
    OWNER to postgres;

-- Index: answerId_Idx
-- DROP INDEX public."answerId_Idx";

CREATE INDEX "answerId_Idx"
    ON public.answers USING btree
    ("answerId" ASC NULLS LAST)
    TABLESPACE pg_default;

--==================== таблица соответствия вопросов и ответов (таблица 'вопрос-ответы')" ================
-- Table: public."questAnswerRef"
-- DROP TABLE public."questAnswerRef";

CREATE TABLE public."questAnswerRef"
(
    "questId" integer NOT NULL,
    "answerId" integer NOT NULL,
    CONSTRAINT "questAnswer_PK" PRIMARY KEY ("questId", "answerId"),
    CONSTRAINT "QuestAnswer" UNIQUE ("questId", "answerId"),
    CONSTRAINT "answerId_FK" FOREIGN KEY ("answerId")
        REFERENCES public.answers ("answerId") MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE RESTRICT
        NOT VALID,
    CONSTRAINT "questId_FK" FOREIGN KEY ("questId")
        REFERENCES public.questions ("questId") MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE RESTRICT
        NOT VALID
)

TABLESPACE pg_default;

ALTER TABLE public."questAnswerRef"
    OWNER to postgres;

-- Index: questAnswer_Idx
-- DROP INDEX public."questAnswer_Idx";

CREATE INDEX "questAnswer_Idx"
    ON public."questAnswerRef" USING btree
    ("questId" ASC NULLS LAST, "answerId" ASC NULLS LAST)
    TABLESPACE pg_default;

--==================== таблица правильных ответов ==================
--============= возможен лишь один правильный ответ на вопрос ======
-- Table: public."rightAnswerRef"
-- DROP TABLE public."rightAnswerRef";

CREATE TABLE public."rightAnswerRef"
(
    "questId" integer NOT NULL,
    "answerId" integer NOT NULL,
    CONSTRAINT "questId_PK" PRIMARY KEY ("questId"),
    CONSTRAINT "answerId_FK" FOREIGN KEY ("answerId")
        REFERENCES public.answers ("answerId") MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT "questId_FK" FOREIGN KEY ("questId")
        REFERENCES public.questions ("questId") MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE RESTRICT
)

TABLESPACE pg_default;

ALTER TABLE public."rightAnswerRef"
    OWNER to postgres;

--=================== Результаты тестирования в разрезе пользователей ==============
-- Table: public."resultQuest"
-- DROP TABLE public."resultQuest";
CREATE TABLE public."resultQuest"
(
    "userId" integer NOT NULL,
    "questId" integer NOT NULL,
    "answerId" integer NOT NULL,
    CONSTRAINT "userQuestAnswer_PK" PRIMARY KEY ("userId", "questId", "answerId"),
    CONSTRAINT "answer_FK" FOREIGN KEY ("answerId")
        REFERENCES public.answers ("answerId") MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE RESTRICT
        NOT VALID,
    CONSTRAINT "quest_FK" FOREIGN KEY ("questId")
        REFERENCES public.questions ("questId") MATCH SIMPLE
        ON UPDATE RESTRICT
        ON DELETE RESTRICT
        NOT VALID,
    CONSTRAINT "user_FK" FOREIGN KEY ("userId")
        REFERENCES public.users ("userId") MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
        NOT VALID
)

TABLESPACE pg_default;

ALTER TABLE public."resultQuest"
    OWNER to postgres;

-- Index: UserId_Idx
-- DROP INDEX public."UserId_Idx";

CREATE INDEX "UserId_Idx"
    ON public."resultQuest" USING btree
    ("userId" ASC NULLS LAST)
    TABLESPACE pg_default;